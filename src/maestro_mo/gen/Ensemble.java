/**
 * Copyright 2018 Felipe Hernández
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the 
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

package maestro_mo.gen;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Hashtable;

import utilities.geom.Point2I;
import maestro_mo.ContVar;
import maestro_mo.DiscVar;
import maestro_mo.Objective;
import maestro_mo.gen.gd.GD;
import maestro_mo.pop.Population;
import maestro_mo.solution.SolutionRoot;
import maestro_mo.solution.SolutionWrapper;

/**
 * Represents an ensemble of generator algorithms that are used alternately to generate new 
 * candidate solutions to a multi-objective problem.
 * @author Felipe Hernández
 */
public class Ensemble implements Generator
{
	
	// --------------------------------------------------------------------------------------------
	// Constants
	// --------------------------------------------------------------------------------------------
	
	/**
	 * Identifier of the ensemble generator
	 */
	public final static String ID = "Generator ensemble";
	
	/**
	 * Short identifier of the ensemble generator
	 */
	public final static String SHORT_ID = "Ens";
	
	/**
	 * Default value for {@link #index}
	 */
	public final static int DEF_INDEX = -1;
	
	/**
	 * Default value for {@link #genRatio}
	 */
	public final static double DEF_GEN_RATIO = 0.15;
	
	/**
	 * Default value for {@link #genMin}
	 */
	public final static double DEF_GEN_MIN = 0.1;
	
	/**
	 * Default value for {@link #absGenMin}
	 */
	public final static int DEF_ABS_GEN_MIN = 0;
	
	/**
	 * Default value for {@link #weightPop}
	 */
	public final static double DEF_WEIGHT_POP = 0.0;
	
	/**
	 * Default value for {@link #weightFront1}
	 */
	public final static double DEF_WEIGHT_FRONT_1 = 1.0;
	
	/**
	 * Error message: no decision variables were defined
	 */
	public final static String ERR_NO_VARIABLES = "No discrete or continuous decision variables "
													+ "were defined";

	/**
	 * Error message: no optimization objectives were defined
	 */
	private static final String ERR_NO_OBJECTIVES = "No optimization objectives were defined";
	
	/**
	 * Error message: the population is null
	 */
	private static final String ERR_POP_NULL = "No population was defined";
	
	/**
	 * Error message: the population is empty
	 */
	private static final String ERR_POP_EMPTY = "The population is empty";
	
	// --------------------------------------------------------------------------------------------
	// Attributes
	// --------------------------------------------------------------------------------------------
	
	/**
	 * The index of the ensemble
	 */
	private int index;
	
	/**
	 * The list with the algorithms that generate values for new solutions 
	 */
	private ArrayList<GenWrapper> generators;
	
	/**
	 * The list of the discrete variables of the problem
	 */
	private ArrayList<DiscVar> discVars;
	
	/**
	 * The list of the continuous variables of the problem
	 */
	private ArrayList<ContVar> contVars;
	
	/**
	 * The list of objectives of the optimization problem
	 */
	private ArrayList<Objective> objectives;
	
	/**
	 * The population to generate candidate solutions for
	 */
	private Population population;
	
	/**
	 * The number of solutions for each generator to generate as a ratio of the 
	 * {@link #population}'s target size when each is showing the same performance. The number of 
	 * solutions to generate is given by:
	 * <i>toGenerate = performanceIndex*{@link #genRatio}*popSize</i>. The performance index is 
	 * computed as: <i>performanceIndex = numberOfGenerators*generatorWeight/totalWeight</i>.
	 */
	private double genRatio;
	
	/**
	 * The minimum number of solutions that should be generated by each generator as a percentage
	 * of the {@link #population}'s target size
	 */
	private double genMin;
	
	/**
	 * The absolute minimum number of solutions that should be generated by each generator
	 */
	private int absGenMin;
	
	/**
	 * The weight given to the percentage of solutions in the entire population that were created 
	 * by a generator to determine its overall relative weight. The overall weight for a generator 
	 * is: <br><i>overallWeight = {@link #weightPop}*%_population + {@link #weightFront1}
	 * *%_first_partition</i>.
	 */
	private double weightPop;
	
	/**
	 * The weight given to the percentage of solutions in the first front of the 
	 * {@link #population} that were created by a generator to determine its overall relative 
	 * weight. The overall weight for a generator is: <br><i>overallWeight = {@link #weightPop}*
	 * %_population + {@link #weightFront1}*%_first_partition</i>.
	 */
	private double weightFront1;
	
	/**
	 * The index of the last generator used
	 */
	private int lastGen;
	
	/**
	 * True if within an inner cycle run not all the generator methods have generated new solutions
	 */
	private boolean firstLap;
	
	/**
	 * The log with the history of the number of generated solutions. Each entry on the log is a 
	 * (Generator short identifier, number of solutions, total time, and time per solution) tuple 
	 * in a string separated by tabs.
	 */
	private ArrayList<String> generationHistory;
	
	/**
	 * True if all the generators in the ensemble have been assigned the list of variables and the
	 * list of objectives. False otherwise.
	 */
	private boolean updated;
	
	// --------------------------------------------------------------------------------------------
	// Constructors
	// --------------------------------------------------------------------------------------------
	
	public Ensemble()
	{
		generators			= new ArrayList<>();
		discVars			= null;
		contVars			= null;
		objectives			= new ArrayList<>();
		population			= null;
		genRatio			= DEF_GEN_RATIO;
		genMin				= DEF_GEN_MIN;
		absGenMin			= DEF_ABS_GEN_MIN;
		weightPop			= DEF_WEIGHT_POP;
		weightFront1		= DEF_WEIGHT_FRONT_1;
		lastGen				= -1;
		firstLap			= true;
		generationHistory	= new ArrayList<>();
		updated				= false;
	}
	
	// --------------------------------------------------------------------------------------------
	// Methods
	// --------------------------------------------------------------------------------------------

	@Override
	public String getId() 
	{
		return ID + (index == -1 ? "" : " " + index);
	}

	@Override
	public String getShortId() 
	{
		return SHORT_ID + (index == -1 ? "" : " " + index);
	}

	/**
	 * @return {@link #generators}
	 */
	public ArrayList<GenWrapper> getGenerators() 
	{
		return generators;
	}

	/**
	 * @param generators {@link #generators}
	 */
	public void setGenerators(ArrayList<GenWrapper> generators) 
	{
		this.generators	= generators;
		updated			= false;
	}

	/**
	 * @return {@link #population}
	 */
	public Population getPopulation() 
	{
		return population;
	}

	/**
	 * @param population {@link #population}
	 */
	public void setPopulation(Population population) 
	{
		this.population = population;
	}

	@Override
	public void addDiscVariable(DiscVar variable) 
	{
		if(discVars == null)
			discVars	= new ArrayList<DiscVar>();
		discVars.add(variable);
		updated			= false;
	}

	@Override
	public void addContVariable(ContVar variable) 
	{
		if(contVars == null)
			contVars	= new ArrayList<ContVar>();
		contVars.add(variable);
		updated			= false;
	}

	@Override
	public void clearVariables() 
	{
		discVars	= null;
		contVars	= null;
		updated		= false;
	}

	/**
	 * @return {@link #genRatio}
	 */
	public double getGenRatio() 
	{
		return genRatio;
	}

	/**
	 * @param genRatio {@link #genRatio}
	 */
	public void setGenRatio(double genRatio)
	{
		this.genRatio = genRatio < 0.0 ? 0.0 : genRatio;
	}

	/**
	 * @return {@link #genMin}
	 */
	public double getGenMin() 
	{
		return genMin;
	}

	/**
	 * @param genMin {@link #genMin}
	 */
	public void setGenMin(double genMin) 
	{
		this.genMin = genMin < 0.0 ? 0.0 : genMin;
	}

	/**
	 * @return {@link #absGenMin}
	 */
	public int getAbsGenMin() 
	{
		return absGenMin;
	}

	/**
	 * @param absGenMin {@link #absGenMin}
	 */
	public void setAbsGenMin(int absGenMin) 
	{
		this.absGenMin = absGenMin < 0 ? 0 : absGenMin;
	}

	/**
	 * @return {@link #weightPop}
	 */
	public double getWeightPop() 
	{
		return weightPop;
	}

	/**
	 * @param weightPop {@link #weightPop}
	 */
	public void setWeightPop(double weightPop) 
	{
		this.weightPop = weightPop < 0.0 ? 0.0 : weightPop;
	}

	/**
	 * @return {@link #weightFront1}
	 */
	public double getWeightFront1() 
	{
		return weightFront1;
	}

	/**
	 * @param weightFront1 {@link #weightFront1}
	 */
	public void setWeightFront1(double weightFront1) 
	{
		this.weightFront1 = weightFront1 < 0.0 ? 0.0 : weightFront1;
	}

	/**
	 * {@link #generationHistory}
	 */
	public ArrayList<String> getGenerationHistory()
	{
		return generationHistory;
	}

	@Override
	public String getParamSummary() 
	{
		String line	= ID + " {";
		for (Generator generator : generators)
			line 	+= generator.getParamSummary() + ", ";
		line		= line.substring(0, line.length() - 3);
		line		+= "}";
		return line;
	}

	@Override
	public ArrayList<SolutionRoot> generateSolutions(Population population, int number)
	{
		this.population		= population;
		ArrayList<SolutionRoot> roots = new ArrayList<>();
		while (roots.size() < number)
			roots.addAll(generateSolutions());
		return roots;
	}
	
	/**
	 * Adds the default generator selection to the ensemble
	 */
	public void defaultGenerators()
	{
		Generator ga		= new GA();
		GenWrapper wrapper	= new GenWrapper(ga);
		addGenWrapper(wrapper);
		
		Generator metroACO	= new MetroACO();
		wrapper				= new GenWrapper(metroACO);
		addGenWrapper(wrapper);
		
		Generator gd		= new GD();
		wrapper				= new GenWrapper(gd);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a new generator to the ensemble
	 * @param generator The generator to add
	 */
	public void addGenerator(Generator generator)
	{
		GenWrapper wrapper = new GenWrapper(generator);
		addGenWrapper(wrapper);
	}

	/**
	 * Adds a {@link GA} generator with default parameters
	 */
	public void addGAGenerator()
	{
		Generator ga		= new GA();
		GenWrapper wrapper	= new GenWrapper(ga);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a {@link MetroACO} generator with default parameters
	 */
	public void addMetroACOGenerator()
	{
		Generator metroACO	= new MetroACO();
		GenWrapper wrapper	= new GenWrapper(metroACO);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a {@link maestro_mo.gen.gd.GD} generator with default parameters
	 */
	public void addGDGenerator()
	{
		Generator gd		= new GD();
		GenWrapper wrapper	= new GenWrapper(gd);
		addGenWrapper(wrapper);
	}
	
	/**
	 * Adds a generator wrapper object to the generator lists and checks names are unique
	 * @param wrapper The generator wrapper to add
	 */
	private void addGenWrapper(GenWrapper wrapper)
	{
		generators.add(wrapper);
		updated = false;
		checkNames();
	}
	
	/**
	 * Adds suffixes to the identifiers of the generators of the same kind to distinguish them
	 */
	private void checkNames()
	{
		Hashtable<String, Point2I> counts = new Hashtable<String, Point2I>();
		for(GenWrapper generator : generators)
		{
			generator.setSuffix("");
			String id = generator.getId();
			if(counts.containsKey(id))
			{
				Point2I point = counts.get(id);
				point.setX(point.getX() + 1);
			}
			else
				counts.put(id, new Point2I(1, 0));
		}
		for(GenWrapper generator : generators)
		{
			String id = generator.getId();
			Point2I point = counts.get(id);
			if(point.getX() > 1)
			{
				point.setY(point.getY() + 1);
				generator.setSuffix(" " + point.getY());
			}
		}
	}
	
	/**
	 * Clears the generator list
	 */
	public void clearGenerators()
	{
		generators.clear();
		updated			= false;
	}
	
	/**
	 * Returns the identifier of the generator method
	 * @param index The index of the generator method
	 * @return The identifier of the generator method
	 */
	public String getGeneratorId(int index)
	{
		if(index == -1)
			return "Random";
		else
			return generators.get(index).getId();
	}
	
	/**
	 * Returns the short identifier of the generator method
	 * @param index The index of the generator method
	 * @return The short identifier of the generator method
	 */
	public String getGeneratorShortId(int index)
	{
		if(index < 0 || index > generators.size() - 1)
			return "Unknown";
		else
			return generators.get(index).getShortId();
	}
	
	/**
	 * Sets the decision variables
	 * @param discVars The list of the discrete variables of the problem
	 * @param contVars The list of the continuous variables of the problem
	 */
	public void setVariables(ArrayList<DiscVar> discVars, ArrayList<ContVar> contVars)
	{
		this.discVars	= discVars;
		this.contVars	= contVars;
		updated			= false;
	}
	
	@Override
	public void setObjectives(ArrayList<Objective> objectives) 
	{
		this.objectives = objectives;
		updated			= false;
	}
	
	/**
	 * Generates new solution roots using the next generator method in line within the ensemble. If 
	 * this generator produces no solutions, the next one is used until at least one solution root 
	 * is generated. The number of solutions produced is defined by the attributes 
	 * {@link #genRatio}, {@link #genMin}, {@link #absGenMin}, and the computed relative weight of
	 * the next generator in line. The generator might return a smaller number though. Do not call
	 * this method before having first defined the generators (optional) and then having set the 
	 * variables ({@link #setVariables(ArrayList, ArrayList)}) and the objectives 
	 * ({@link #setObjectives(ArrayList)}). 
	 * @return A list of generated solution roots
	 */
	public synchronized ArrayList<SolutionRoot> generateSolutions()
	{
		// Check if the optimization problem was formulated in a valid way
		if (discVars == null && contVars == null)
			throw new RuntimeException(ERR_NO_VARIABLES);
		if (objectives.size() == 0)
			throw new RuntimeException(ERR_NO_OBJECTIVES);
		if (population == null)
			throw new RuntimeException(ERR_POP_NULL);
		else if (population.size() == 0)
			throw new RuntimeException(ERR_POP_EMPTY);
		
		// Prepare generators
		if (!updated)
		{
			if (generators.size() == 0)
				defaultGenerators();
			else
				for (Generator gen : generators)
					gen.clearVariables();
			if (discVars != null)
				for (DiscVar var : discVars)
					for (Generator gen : generators)
						gen.addDiscVariable(var);
			if (contVars != null)
				for (ContVar var : contVars)
					for (Generator gen : generators)
						gen.addContVariable(var);
			for (Generator gen : generators)
				gen.setObjectives(objectives);
			updated = true;
		}
		
		// Generate roots
		ArrayList<SolutionRoot> roots = new ArrayList<>();
		while (roots.size() == 0)
			roots.addAll(attemptGeneration());
		return roots;
	}

	/**
	 * Generates new solution roots using the next generator method in line within the ensemble
	 * @return A list of generated solution roots
	 */
	private Collection<? extends SolutionRoot> attemptGeneration() 
	{
		// Select generator
		GenWrapper gen			= null;
		int genCount 			= 0;
		boolean okGen			= false;
		int zeroGen				= 0;
		while(!okGen)
		{
			// Update last generator index
			if(lastGen == generators.size() - 1)
			{
				lastGen 		= 0;
				firstLap 		= false;
			}
			else
				lastGen 		= lastGen + 1;
			
			gen 				= generators.get(lastGen);
			genCount 			= 0;
			synchronized(population)
			{
				// Compute the number of solutions to generate
				int popSize		= population.getCapacity();
				if(firstLap || zeroGen >= generators.size())
					genCount 	= Math.max(1, (int)(genRatio*popSize));
				else
					genCount 	= computeGenCount(lastGen);
				genCount 		= Math.max(genCount, Math.max(absGenMin, (int)(genMin*popSize)));
			
				if(genCount > 0)
					okGen		= true;
				else
					zeroGen++;
			}
		}
		
		// Generate new solutions
		long startTime 			= System.currentTimeMillis();
		ArrayList<SolutionRoot> roots;
		try
		{
			roots				= gen.generateSolutions(population, genCount);
			roots				= roots == null ? new ArrayList<>() : roots;
		}
		catch (Exception e)
		{
			e.printStackTrace();
			roots				= new ArrayList<>();
		}
		long delta				= System.currentTimeMillis() - startTime;
		int count				= roots.size();
		double perSolution		= count == 0 ? 0.0 : ((double)delta)/count;
		for(SolutionRoot root : roots)
			root.setGenIndex(lastGen);
		generationHistory.add(gen.getShortId() + "\t" + count + "\t" + delta + "\t" + perSolution);		
		return roots;
	}

	/**
	 * Computes the number of solutions to generate by taking into account the relative weight of
	 * the generator as compared with that of the other generators
	 * @param genIndex The index of the generator
	 * @return The number of solutions to generate
	 */
	private int computeGenCount(int genIndex)
	{
		// Compute generator weight
		int count			= 0;
		int total			= 0;
		int countF1			= 0;
		int totalF1			= 0;
		for (SolutionWrapper solution : population.getAllSolutions())
		{
			int solGenIndex	= solution.getGenIndex();
			count			+= solGenIndex == genIndex ? 1 : 0;
			total++;
			if (solution.getRank() == 1)
			{
				countF1		+= solGenIndex == genIndex ? 1 : 0;
				totalF1		++;
			}
		}
		double popPercent	= (double)count/total;
		double f1Percent	= (double)countF1/totalF1;
		double genWeight	= weightPop*popPercent + weightFront1*f1Percent;
		double weightSum	= weightPop + weightFront1;
		
		// Compute the number of solutions to generate
		double popSize		= population.getCapacity();
		double base = ((double)generators.size()*genWeight/weightSum);
		return Double.isNaN(base) ? 0 : (int)(popSize*genRatio*base);
	}

}
