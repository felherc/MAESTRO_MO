/**
 * Copyright 2018 Felipe Hernández
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the 
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

package maestro_mo;

import java.io.IOException;
import java.util.ArrayList;

import maestro_mo.gen.GenWrapper;
import maestro_mo.gen.Generator;
import maestro_mo.pop.Population;
import maestro_mo.solution.Solution;
import maestro_mo.solution.SolutionRoot;
import maestro_mo.solution.SolutionWrapper;

/**
 * This is the main class of MAESTRO-MO: Multi-Algorithm Ensemble for Several-Threats Robust
 * Optimization (Multi-Objective). It allows to solve global multi-objective optimization problems 
 * which may contain discrete decision variables, continuous decision variables, or a mixture of 
 * them. Candidate solutions are generated by an ensemble of meta-heuristic algorithms that include 
 * a Genetic Algorithm (GA), a Gradient Descent (GD) algorithm, and a hybrid Metropolis-Ant Colony 
 * Optimization (MetroACO) algorithm. An interface is used so that additional meta-heuristics can
 * be used. MAESTRO can be run in parallel to take advantage of multiple CPUs.
 * @author Felipe Hernández
 */
public class MAESTRO
{

	// --------------------------------------------------------------------------------------------
	// Attributes
	// --------------------------------------------------------------------------------------------
	
	/**
	 * The instance of the MAESTRO optimizer class
	 */
	private Optimizer optimizer;
	
	// --------------------------------------------------------------------------------------------
	// Constructor
	// --------------------------------------------------------------------------------------------
	
	/**
	 * @param problem		The name of the optimization problem being solved 
	 * @param runIndex		An index that identifies the current run of the optimization algorithm 
	 * @param solution		The solution object that allows to create and evaluate new solutions
	 * @param monitor		The instance of the object implementing the {@link Monitor} interface 
	 * 						to communicate with the caller application
	 * @param keepHistory	True if all solutions generated should be stored. False otherwise.
	 */
	public MAESTRO(String problem, int runIndex, Solution solution, Monitor monitor,
			boolean keepHistory)
	{
		optimizer = new Optimizer(problem, runIndex, solution, monitor, keepHistory);
	}
	
	// --------------------------------------------------------------------------------------------
	// Methods
	// --------------------------------------------------------------------------------------------
	
	/**
	 * @return The name of the optimization problem being solved 
	 */
	public String getProblem() 
	{
		return optimizer.getProblem();
	}

	/**
	 * @param problem The name of the optimization problem being solved 
	 */
	public void setProblem(String problem) 
	{
		optimizer.setProblem(problem);
	}

	/**
	 * @return An index that identifies the current run of the optimization algorithm 
	 */
	public int getRunIndex() 
	{
		return optimizer.getRunIndex();
	}

	/**
	 * @param runIndex An index that identifies the current run of the optimization algorithm 
	 */
	public void setRunIndex(int runIndex) 
	{
		optimizer.setRunIndex(runIndex);;
	}

	/**
	 * @return The list of the discrete variables of the problem
	 */
	public ArrayList<DiscVar> getDiscVars()
	{
		return optimizer.getDiscVars();
	}

	/**
	 * @return The list of the continuous variables of the problem
	 */
	public ArrayList<ContVar> getContVars()
	{
		return optimizer.getContVars();
	}

	/**
	 * @return The list of objectives of the optimization problem
	 */
	public ArrayList<Objective> getObjectives()
	{
		return optimizer.getObjectives();
	}

	/**
	 * @return The solution object that allows to create and evaluate new solutions
	 */
	public Solution getSolution()
	{
		return optimizer.getSolution();
	}
	
	/**
	 * @return A group of solutions to the optimization problem organized using a customized 
	 * strategy for balancing the trade-offs between the multiple objectives. The population has 
	 * a limited capacity and it is supposed to maintain the most worthwhile solutions found so 
	 * far.
	 */
	public Population getPopulation() 
	{
		return optimizer.getPopulation();
	}
	
	/**
	 * @return The number of concurrent threads to process new solutions
	 */
	public int getThreadCount() 
	{
		return optimizer.getThreadCount();
	}

	/**
	 * @param threadCount The number of concurrent threads to process new solutions
	 */
	public void setThreadCount(int threadCount)
	{
		optimizer.setThreadCount(threadCount);
	}
	
	/**
	 * @return True if the generation of new solutions and the updating of the population are 
	 * allowed to happen on a different thread. False if all should run sequentially.
	 */
	public boolean getConcurrentUpdates() 
	{
		return optimizer.getConcurrentUpdates();
	}

	/**
	 * @param concurrentUpdates True if the generation of new solutions and the updating of the 
	 * population are allowed to happen on a different thread. False if all should run 
	 * sequentially.
	 */
	public void setConcurrentUpdates(boolean concurrentUpdates) 
	{
		optimizer.setConcurrentUpdates(concurrentUpdates);
	}

	/**
	 * @return The number of solutions for each generator to generate as a ratio of the 
	 * population's target size when each is showing the same performance. The number of 
	 * solutions to generate is given by:
	 * <i>toGenerate = performanceIndex*genRatio*popSize</i>. The performance index is 
	 * computed as: <i>performanceIndex = numberOfGenerators*generatorWeight/totalWeight</i>.
	 */
	public double getGenRatio() 
	{
		return optimizer.getGenRatio();
	}
	
	/**
	 * @param genRatio The number of solutions for each generator to generate as a ratio of the 
	 * population's target size when each is showing the same performance. The number of 
	 * solutions to generate is given by:
	 * <i>toGenerate = performanceIndex*genRatio*popSize</i>. The performance index is 
	 * computed as: <i>performanceIndex = numberOfGenerators*generatorWeight/totalWeight</i>.
	 */
	public void setGenRatio(double genRatio)
	{
		optimizer.setGenRatio(genRatio);
	}
	
	/**
	 * @return The minimum number of solutions that should be generated by each generator as a 
	 * percentage of the population's target size
	 */
	public double getGenMin() 
	{
		return optimizer.getGenMin();
	}
	
	/**
	 * @param genMin The minimum number of solutions that should be generated by each generator as 
	 * a percentage of the population's target size
	 */
	public void setGenMin(double genMin)
	{
		optimizer.setGenMin(genMin);
	}
	
	/**
	 * @return The absolute minimum number of solutions that should be generated by each generator
	 */
	public int getAbsGenMin() 
	{
		return optimizer.getAbsGenMin();
	}
	
	/**
	 * @param absGenMin The absolute minimum number of solutions that should be generated by each 
	 * generator
	 */
	public void setAbsGenMin(int absGenMin) 
	{
		optimizer.setAbsGenMin(absGenMin);
	}
	
	/**
	 * @return The weight given to the percentage of solutions in the entire population that were 
	 * created by a generator to determine its overall relative weight. The overall weight for a 
	 * generator is: <br><i>overallWeight = weightPop*%_population + weightFront1
	 * *%_first_partition</i>.
	 */
	public double getWeightPop() 
	{
		return optimizer.getWeightPop();
	}
	
	/**
	 * @param weightPop The weight given to the percentage of solutions in the entire population 
	 * that were created by a generator to determine its overall relative weight. The overall 
	 * weight for a generator is: <br><i>overallWeight = weightPop*%_population + weightFront1
	 * *%_first_partition</i>.
	 */
	public void setWeightPop(double weightPop) 
	{
		optimizer.setWeightPop(weightPop);
	}
	
	/**
	 * @return The weight given to the percentage of solutions in the first front of the 
	 * population that were created by a generator to determine its overall relative weight. The 
	 * overall weight for a generator is: <br><i>overallWeight = weightPop*%_population + 
	 * weightFront1*%_first_partition</i>.
	 */
	public double getWeightFront1() 
	{
		return optimizer.getWeightFront1();
	}
	
	/**
	 * @param weightFront1 The weight given to the percentage of solutions in the first front of 
	 * the population that were created by a generator to determine its overall relative 
	 * weight. The overall weight for a generator is: <br><i>overallWeight = weightPop*
	 * %_population + weightFront1*%_first_partition</i>.
	 */
	public void setWeightFront1(double weightFront1) 
	{
		optimizer.setWeightFront1(weightFront1);
	}
	
	/**
	 * @return The target size of the current population
	 */
	public int getPopulationCapacity()
	{
		return optimizer.getPopulationCapacity();
	}
	
	/**
	 * @param capacity The target size of the current population
	 */
	public void setPopulationCapacity(int capacity)
	{
		optimizer.setPopulationCapacity(capacity);
	}
	
	/**
	 * @return <code>true</code> if solutions with different defining values but with exactly the 
	 * same performance should be allowed in the population. (Only numerical objectives are taken 
	 * into account for the sake of performance.)
	 */
	public boolean areEqPerformersAllowed()
	{
		return optimizer.areEqPerformersAllowed();
	}
	
	/**
	 * @param allowEqPerformers <code>true</code> if solutions with different defining values but 
	 * with exactly the same performance should be allowed in the population. (Only numerical 
	 * objectives are taken into account for the sake of performance.)
	 */
	public void allowEqPerformers(boolean allowEqPerformers)
	{
		optimizer.allowEqPerformers(allowEqPerformers);
	}
	
	/**
	 * @return The maximum number of milliseconds an evaluation is allowed to run before it is 
	 * discarded. -1 if evaluations should never be stopped.
	 */
	public long getEvaluationTimeLimit()
	{
		return optimizer.getEvaluationTimeLimit();
	}

	/**
	 * @param evaluationTimeLimit The maximum number of milliseconds an evaluation is allowed to 
	 * run before it is discarded. -1 if evaluations should never be stopped.
	 */
	public void setEvaluationTimeLimit(long evaluationTimeLimit)
	{
		optimizer.setEvaluationTimeLimit(evaluationTimeLimit);
	}
	
	/**
	 * @return The number of solutions to be created randomly at the beginning of the optimization 
	 * process as the percentage of the {@link #population}'s capacity. If smaller than 1.0, it can 
	 * only be honored if there are enough user predefined solutions to complete the initial 
	 * population.
	 */
	public double getRandomSolutionRatio()
	{
		return optimizer.getRandomSolutionRatio();
	}

	/**
	 * @param randomSolutionRatio The number of solutions to be created randomly at the beginning 
	 * of the optimization process as the percentage of the {@link #population}'s capacity. If 
	 * smaller than 1.0, it can only be honored if there are enough user predefined solutions to 
	 * complete the initial population.
	 */
	public void setRandomSolutionRatio(double randomSolutionRatio)
	{
		optimizer.setRandomSolutionRatio(randomSolutionRatio);
	}
	
	/**
	 * @return The maximum optimization time in milliseconds
	 */
	public long getTimeLimit()
	{
		return optimizer.getTimeLimit();
	}
	
	/**
	 * @return The maximum number of solutions to be evaluated
	 */
	public int getSolutionLimit()
	{
		return optimizer.getSolutionLimit();
	}
	
	/**
	 * @return The optimization starting time in milliseconds
	 */
	public long getStartTime()
	{
		return optimizer.getStartTime();
	}
	
	/**
	 * @return The number of solutions evaluated so far
	 */
	public int getSolutionCount()
	{
		return optimizer.getEvalCount();
	}
	
	/**
	 * @return The list of solutions in the first front of the population
	 */
	public ArrayList<SolutionWrapper> getFirstFront()
	{
		return optimizer.getFirstFront();
	}
	
	/**
	 * @return The list of solutions in the population
	 */
	public ArrayList<SolutionWrapper> getSolutionsInPopulation()
	{
		return optimizer.getSolutionsInPopulation();
	}
	
	/**
	 * @return A list with all solutions evaluated. <code>null</code> if the history is not to be 
	 * kept as defined when calling the constructor.
	 */
	public ArrayList<SolutionWrapper> getAllSolutions()
	{
		return optimizer.getAllSolutions();
	}
	
	/**
	 * @return The list of solutions in the hall of fame in the order they were created
	 */
	public ArrayList<SolutionWrapper> getHallOfFame()
	{
		return optimizer.getHallOfFame();
	}
	
	/**
	 * @return The file route for the file to save the hall of fame (A list with all the solutions 
	 * that at any time made part of the first front of the population) to. "" if no file should be 
	 * created.
	 */
	public String getHallOfFameFile()
	{
		return optimizer.getHallOfFameFile();
	}

	/**
	 * @param hallOfFameFile The file route for the file to save the hall of fame (A list with all 
	 * the solutions that at any time made part of the first front of the population) to. "" if no 
	 * file should be created.
	 * @throws IOException If there is a problem creating the file
	 */
	public void setHallOfFameFile(String hallOfFameFile) throws IOException
	{
		optimizer.setHallOfFameFile(hallOfFameFile);
	}
	
	/**
	 * Adds a new discrete optimization variable with its possible values. The values are the 
	 * specified number of integers starting from the <code>min</code> value and sequentially on.
	 * @param name The identifier of the variable
	 * @param min The minimum integer value the variable can take
	 * @param count The number of values the variable can take
	 * @param scalar True if the values of the variable correspond to a scale
	 */
	public void addDiscVar(String name, int min, int count, boolean scalar)
	{
		optimizer.addDiscVar(name, min, count, scalar);
	}
	
	/**
	 * Adds a new discrete optimization variable with its possible values. The values are integers 
	 * from 0 and on, that map to the set of identifiers.
	 * @param name The identifier of the variable
	 * @param values The set of identifiers of the variable's possible values
	 * @param scalar True if the values of the variable correspond to a scale
	 */
	public void addDiscVar(String name, ArrayList<String> values, boolean scalar)
	{
		optimizer.addDiscVar(name, values, scalar);
	}
	
	/**
	 * @param discVars The list of the discrete variables of the problem
	 */
	public void setDiscVars(ArrayList<DiscVar> discVars)
	{
		optimizer.setDiscVars(discVars);
	}
	
	/**
	 * Adds a new continuous optimization variable
	 * @param name Identifier of the variable
	 * @param min The minimum value the variable can take
	 * @param max The maximum value the variable can take
	 */
	public void addContVar(String name, double min, double max)
	{
		optimizer.addContVar(name, min, max);
	}
	
	/**
	 * @param contVars The list of the continuous variables of the problem
	 */
	public void setContVars(ArrayList<ContVar> contVars)
	{
		optimizer.setContVars(contVars);
	}
	
	/**
	 * @param index The index of the variable
	 * @return The name of the discrete variable
	 */
	public String getDiscVarName(int index)
	{
		return optimizer.getDiscVarName(index);
	}
	
	/**
	 * @param varIndex The index of the variable
	 * @param value The index of the value
	 * @return The identifier of the value of a variable
	 */
	public String getDiscValueID(int varIndex, int value)
	{
		return optimizer.getDiscValueID(varIndex, value);
	}
	
	/**
	 * @param index The index of the variable
	 * @return The name of the continuous variable
	 */
	public String getContVarName(int index)
	{
		return optimizer.getContVarName(index);
	}
	
	/**
	 * Validates that the values in the provided array are within the valid range of the 
	 * discrete optimization variables. Any values outside the range are replaced by the 
	 * corresponding limit.
	 * @param discValues The list of values to validate
	 */
	public void validateDiscValues(ArrayList<Integer> discValues)
	{
		optimizer.validateDiscValues(discValues);
	}
	
	/**
	 * Validates that the values in the provided array are within the valid range of the 
	 * continuous optimization variables. Any values outside the range are replaced by the 
	 * corresponding limit.
	 * @param contValues The list of values to validate
	 */
	public void validateContValues(ArrayList<Double> contValues)
	{
		optimizer.validateContValues(contValues);
	}
	
	/**
	 * Adds a new numerical comparing optimization objective. Solutions are compared through 
	 * the values obtained in {@link maestro_mo.solution.Solution#getFitness}.
	 * @param index The unique index of the objective
	 * @param id The identifier of the objective
	 * @param maximization True if the numerical fitness value for this objective is to be 
	 * maximized. False if it is to be minimized.
	 */
	public void addNumericalObjective(int index, String id, boolean maximization)
	{
		optimizer.addNumericalObjective(index, id, maximization);
	}
	
	/**
	 * Adds a new custom optimization objective. Instead of comparing a single numerical value,
	 * the custom objective calls the {@link maestro_mo.solution.Solution#compareTo} custom 
	 * function.
	 * @param index The unique index of the objective
	 * @param id The identifier of the objective
	 */
	public void addCustomObjective(int index, String id)
	{
		optimizer.addCustomObjective(index, id);
	}
	
	/**
	 * Adds a new low-level optimization algorithm or generator to the {@link #ensemble}. If no 
	 * custom generators are added, a default ensemble is used.
	 * @param generator The low-level optimization algorithm to add
	 */
	public void addGenerator(Generator generator)
	{
		optimizer.addGenerator(generator);
	}
	
	/**
	 * @return The list with the algorithms that generate values for new solutions 
	 */
	public ArrayList<GenWrapper> getGenerators()
	{
		return optimizer.getGenerators();
	}
	
	/**
	 * @param genIndex The index of the generator method
	 * @return The identifier of the generator method
	 */
	public String getGeneratorId(int genIndex)
	{
		return optimizer.getGeneratorId(genIndex);
	}
	
	/**
	 * @param genIndex The index of the generator method
	 * @return The short identifier of the generator method
	 */
	public String getGeneratorShortId(int genIndex)
	{
		return optimizer.getGeneratorShortId(genIndex);
	}
	
	/**
	 * Adds a predefined solution root to be analyzed and offered to the population
	 * @param root The solution root to add
	 */
	public void addPredefinedSolution(SolutionRoot root)
	{
		optimizer.addPredefinedSolution(root);
	}
	
	/**
	 * Initializes the optimization process which runs until the time limit is reached, the maximum
	 * number of solutions is generated or the method <code>terminate()</code> is called. When the 
	 * process is finished, the method <code>terminate()</code> in the <code>Monitor</code> is 
	 * called.
	 * @param timeLimit The time limit for the optimization process in milliseconds
	 * @param solutionLimit The maximum number of candidate solutions that should be processed
	 */
	public synchronized void startOptimization(long timeLimit, int solutionLimit)
	{
		optimizer.startOptimization(timeLimit, solutionLimit);
	}
	
	/**
	 * Writes a report file containing the results from the execution of MAESTRO
	 * @param customFileName	True if a custom file name will be provided; false if the file
	 * 							name should be generated using the {@link #problem} and the 
	 * 							{@link #runIndex}
	 * @param folder			The system path of the folder to save the report; complete path
	 * 							if <code>customFileName</code> is true
	 * @param writeConfig 		True if the parameters and generators of MAESTRO should be included
	 * @param entirePopulation	True if the entire population should be included; false if only the
	 * 							Pareto (first) front should be included
	 * @param writeGenHist 		True if the history of generators used should be included
	 * @param writeHallOfFame	True if the solutions in the hall of fame should be included
	 * @param writeAllSolutions	True if all solutions should be included
	 * @throws IOException		If the file (or files) can not be created
	 */
	public void writeReport(boolean customFileName, String folder, 
			boolean writeConfig, boolean entirePopulation, boolean writeGenHist, 
			boolean writeHallOfFame, boolean writeAllSolutions) throws IOException
	{
		optimizer.writeReport(customFileName, folder, writeConfig, entirePopulation, 
										writeGenHist, writeHallOfFame, writeAllSolutions);
	}
	
}
